// Iris Classification Loss Function
// Network: 4 inputs -> 4 hidden (tanh) -> 3 outputs (softmax)
// Parameters (35 total):
//   pos[0-15]:  W1 (4x4 input->hidden weights, row-major)
//   pos[16-19]: b1 (4 hidden biases)
//   pos[20-31]: W2 (4x3 hidden->output weights, output-major)
//   pos[32-34]: b2 (3 output biases)

// Embedded Iris dataset (120 samples, normalized)
// Features: sepal_length, sepal_width, petal_length, petal_width
// Labels: 0=Setosa, 1=Versicolor, 2=Virginica

const IRIS_SIZE: u32 = 120u;

// Iris features stored as 4 arrays
const IRIS_F0: array<f32, 120> = array<f32, 120>(
    // Setosa (40 samples)
    0.222, 0.167, 0.111, 0.083, 0.194, 0.306, 0.083, 0.194, 0.028, 0.167,
    0.306, 0.139, 0.139, 0.000, 0.417, 0.389, 0.306, 0.222, 0.389, 0.222,
    0.306, 0.222, 0.083, 0.222, 0.139, 0.194, 0.194, 0.250, 0.250, 0.111,
    0.139, 0.306, 0.250, 0.333, 0.167, 0.194, 0.333, 0.167, 0.028, 0.222,
    // Versicolor (40 samples)
    0.389, 0.556, 0.500, 0.194, 0.472, 0.333, 0.528, 0.083, 0.472, 0.222,
    0.139, 0.361, 0.306, 0.389, 0.222, 0.389, 0.361, 0.278, 0.278, 0.167,
    0.361, 0.278, 0.444, 0.278, 0.361, 0.389, 0.500, 0.528, 0.361, 0.194,
    0.194, 0.194, 0.250, 0.472, 0.167, 0.361, 0.389, 0.333, 0.222, 0.361,
    // Virginica (40 samples)
    0.556, 0.500, 0.639, 0.417, 0.528, 0.611, 0.222, 0.583, 0.472, 0.667,
    0.556, 0.472, 0.528, 0.389, 0.389, 0.528, 0.528, 0.667, 0.750, 0.361,
    0.583, 0.361, 0.750, 0.389, 0.528, 0.611, 0.333, 0.361, 0.472, 0.556,
    0.639, 0.722, 0.472, 0.389, 0.333, 0.583, 0.556, 0.500, 0.417, 0.444
);

const IRIS_F1: array<f32, 120> = array<f32, 120>(
    // Setosa
    0.625, 0.417, 0.500, 0.458, 0.667, 0.792, 0.583, 0.583, 0.375, 0.458,
    0.708, 0.583, 0.417, 0.417, 0.833, 1.000, 0.792, 0.625, 0.750, 0.750,
    0.583, 0.708, 0.667, 0.542, 0.583, 0.417, 0.583, 0.625, 0.583, 0.500,
    0.458, 0.583, 0.875, 0.917, 0.458, 0.500, 0.625, 0.667, 0.417, 0.583,
    // Versicolor
    0.333, 0.500, 0.333, 0.167, 0.375, 0.208, 0.458, 0.167, 0.375, 0.208,
    0.000, 0.333, 0.125, 0.333, 0.333, 0.417, 0.333, 0.250, 0.125, 0.167,
    0.292, 0.417, 0.208, 0.333, 0.292, 0.375, 0.417, 0.333, 0.250, 0.208,
    0.125, 0.125, 0.250, 0.083, 0.208, 0.417, 0.333, 0.083, 0.208, 0.333,
    // Virginica
    0.292, 0.167, 0.375, 0.292, 0.333, 0.417, 0.083, 0.333, 0.208, 0.542,
    0.375, 0.208, 0.333, 0.167, 0.292, 0.292, 0.333, 0.417, 0.500, 0.125,
    0.458, 0.208, 0.417, 0.208, 0.375, 0.292, 0.125, 0.208, 0.292, 0.458,
    0.458, 0.458, 0.292, 0.208, 0.208, 0.500, 0.208, 0.333, 0.333, 0.292
);

const IRIS_F2: array<f32, 120> = array<f32, 120>(
    // Setosa
    0.068, 0.068, 0.051, 0.085, 0.068, 0.119, 0.068, 0.085, 0.068, 0.085,
    0.085, 0.102, 0.068, 0.017, 0.034, 0.085, 0.051, 0.068, 0.119, 0.085,
    0.119, 0.085, 0.000, 0.119, 0.153, 0.102, 0.102, 0.085, 0.068, 0.102,
    0.102, 0.085, 0.085, 0.068, 0.085, 0.034, 0.051, 0.068, 0.051, 0.085,
    // Versicolor
    0.593, 0.627, 0.627, 0.390, 0.593, 0.508, 0.593, 0.390, 0.542, 0.424,
    0.424, 0.475, 0.424, 0.542, 0.424, 0.542, 0.542, 0.424, 0.508, 0.475,
    0.542, 0.458, 0.593, 0.593, 0.458, 0.542, 0.610, 0.593, 0.508, 0.390,
    0.424, 0.458, 0.458, 0.508, 0.593, 0.508, 0.610, 0.508, 0.424, 0.458,
    // Virginica
    0.797, 0.678, 0.780, 0.695, 0.729, 0.814, 0.576, 0.780, 0.661, 0.797,
    0.780, 0.729, 0.695, 0.780, 0.831, 0.729, 0.695, 0.712, 0.847, 0.559,
    0.763, 0.610, 0.831, 0.678, 0.746, 0.729, 0.678, 0.661, 0.695, 0.729,
    0.763, 0.864, 0.695, 0.627, 0.610, 0.712, 0.678, 0.661, 0.695, 0.695
);

const IRIS_F3: array<f32, 120> = array<f32, 120>(
    // Setosa
    0.042, 0.042, 0.042, 0.042, 0.042, 0.125, 0.083, 0.042, 0.042, 0.000,
    0.042, 0.042, 0.000, 0.000, 0.042, 0.125, 0.125, 0.083, 0.083, 0.083,
    0.042, 0.125, 0.042, 0.167, 0.042, 0.042, 0.125, 0.042, 0.042, 0.042,
    0.042, 0.125, 0.000, 0.042, 0.000, 0.042, 0.042, 0.000, 0.042, 0.042,
    // Versicolor
    0.500, 0.458, 0.542, 0.375, 0.542, 0.500, 0.583, 0.375, 0.458, 0.417,
    0.375, 0.417, 0.375, 0.500, 0.542, 0.458, 0.500, 0.375, 0.417, 0.417,
    0.583, 0.375, 0.542, 0.458, 0.417, 0.417, 0.542, 0.500, 0.458, 0.375,
    0.417, 0.417, 0.417, 0.375, 0.458, 0.500, 0.500, 0.375, 0.375, 0.417,
    // Virginica
    0.625, 0.583, 0.708, 0.750, 0.625, 0.875, 0.542, 0.792, 0.583, 0.833,
    0.708, 0.583, 0.500, 0.833, 0.750, 0.625, 0.625, 0.917, 0.833, 0.500,
    0.708, 0.583, 0.625, 0.792, 0.708, 0.750, 0.583, 0.542, 0.625, 0.667,
    0.833, 0.917, 0.625, 0.750, 0.500, 0.917, 0.750, 0.708, 0.958, 0.625
);

// Labels: 0-39 = class 0, 40-79 = class 1, 80-119 = class 2
fn iris_label(idx: u32) -> u32 {
    return idx / 40u;
}

fn custom_loss(pos: array<f32, 64>, dim: u32) -> f32 {
    var total_loss = 0.0;

    for (var i = 0u; i < IRIS_SIZE; i = i + 1u) {
        // Get input features
        let x0 = IRIS_F0[i];
        let x1 = IRIS_F1[i];
        let x2 = IRIS_F2[i];
        let x3 = IRIS_F3[i];

        // Layer 1: 4 -> 4 (tanh)
        let h0 = tanh(pos[0] * x0 + pos[1] * x1 + pos[2] * x2 + pos[3] * x3 + pos[16]);
        let h1 = tanh(pos[4] * x0 + pos[5] * x1 + pos[6] * x2 + pos[7] * x3 + pos[17]);
        let h2 = tanh(pos[8] * x0 + pos[9] * x1 + pos[10] * x2 + pos[11] * x3 + pos[18]);
        let h3 = tanh(pos[12] * x0 + pos[13] * x1 + pos[14] * x2 + pos[15] * x3 + pos[19]);

        // Layer 2: 4 -> 3 (logits)
        let z0 = pos[20] * h0 + pos[21] * h1 + pos[22] * h2 + pos[23] * h3 + pos[32];
        let z1 = pos[24] * h0 + pos[25] * h1 + pos[26] * h2 + pos[27] * h3 + pos[33];
        let z2 = pos[28] * h0 + pos[29] * h1 + pos[30] * h2 + pos[31] * h3 + pos[34];

        // Stable softmax + cross-entropy
        let max_z = max(max(z0, z1), z2);
        let e0 = exp(z0 - max_z);
        let e1 = exp(z1 - max_z);
        let e2 = exp(z2 - max_z);
        let sum_e = e0 + e1 + e2;

        // Cross-entropy loss
        let label = iris_label(i);
        var log_prob = 0.0;
        if label == 0u {
            log_prob = log(e0 / sum_e + 0.0001);
        } else if label == 1u {
            log_prob = log(e1 / sum_e + 0.0001);
        } else {
            log_prob = log(e2 / sum_e + 0.0001);
        }
        total_loss = total_loss - log_prob;
    }

    return total_loss / f32(IRIS_SIZE);
}
